{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\n * Copyright (c) 2021, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\nvar Chess = function Chess(fen) {\n  var BLACK = 'b';\n  var WHITE = 'w';\n  var EMPTY = -1;\n  var PAWN = 'p';\n  var KNIGHT = 'n';\n  var BISHOP = 'b';\n  var ROOK = 'r';\n  var QUEEN = 'q';\n  var KING = 'k';\n  var SYMBOLS = 'pnbrqkPNBRQK';\n  var DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\n  var TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n  var PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15]\n  };\n  var PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1]\n  }; // prettier-ignore\n\n  var ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20]; // prettier-ignore\n\n  var RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\n  var SHIFTS = {\n    p: 0,\n    n: 1,\n    b: 2,\n    r: 3,\n    q: 4,\n    k: 5\n  };\n  var FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q'\n  };\n  var BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n  };\n  var RANK_1 = 7;\n  var RANK_2 = 6;\n  var RANK_3 = 5;\n  var RANK_4 = 4;\n  var RANK_5 = 3;\n  var RANK_6 = 2;\n  var RANK_7 = 1;\n  var RANK_8 = 0; // prettier-ignore\n\n  var SQUARES = {\n    a8: 0,\n    b8: 1,\n    c8: 2,\n    d8: 3,\n    e8: 4,\n    f8: 5,\n    g8: 6,\n    h8: 7,\n    a7: 16,\n    b7: 17,\n    c7: 18,\n    d7: 19,\n    e7: 20,\n    f7: 21,\n    g7: 22,\n    h7: 23,\n    a6: 32,\n    b6: 33,\n    c6: 34,\n    d6: 35,\n    e6: 36,\n    f6: 37,\n    g6: 38,\n    h6: 39,\n    a5: 48,\n    b5: 49,\n    c5: 50,\n    d5: 51,\n    e5: 52,\n    f5: 53,\n    g5: 54,\n    h5: 55,\n    a4: 64,\n    b4: 65,\n    c4: 66,\n    d4: 67,\n    e4: 68,\n    f4: 69,\n    g4: 70,\n    h4: 71,\n    a3: 80,\n    b3: 81,\n    c3: 82,\n    d3: 83,\n    e3: 84,\n    f3: 85,\n    g3: 86,\n    h3: 87,\n    a2: 96,\n    b2: 97,\n    c2: 98,\n    d2: 99,\n    e2: 100,\n    f2: 101,\n    g2: 102,\n    h2: 103,\n    a1: 112,\n    b1: 113,\n    c1: 114,\n    d1: 115,\n    e1: 116,\n    f1: 117,\n    g1: 118,\n    h1: 119\n  };\n  var ROOKS = {\n    w: [{\n      square: SQUARES.a1,\n      flag: BITS.QSIDE_CASTLE\n    }, {\n      square: SQUARES.h1,\n      flag: BITS.KSIDE_CASTLE\n    }],\n    b: [{\n      square: SQUARES.a8,\n      flag: BITS.QSIDE_CASTLE\n    }, {\n      square: SQUARES.h8,\n      flag: BITS.KSIDE_CASTLE\n    }]\n  };\n\n  var _board = new Array(128);\n\n  var kings = {\n    w: EMPTY,\n    b: EMPTY\n  };\n  var _turn = WHITE;\n  var castling = {\n    w: 0,\n    b: 0\n  };\n  var ep_square = EMPTY;\n  var half_moves = 0;\n  var move_number = 1;\n  var _history = [];\n  var header = {};\n  var comments = {};\n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n\n  if (typeof fen === 'undefined') {\n    _load(DEFAULT_POSITION);\n  } else {\n    _load(fen);\n  }\n\n  function _clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n\n    _board = new Array(128);\n    kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    _turn = WHITE;\n    castling = {\n      w: 0,\n      b: 0\n    };\n    ep_square = EMPTY;\n    half_moves = 0;\n    move_number = 1;\n    _history = [];\n    if (!keep_headers) header = {};\n    comments = {};\n    update_setup(generate_fen());\n  }\n\n  function prune_comments() {\n    var reversed_history = [];\n    var current_comments = {};\n\n    var copy_comment = function copy_comment(fen) {\n      if (fen in comments) {\n        current_comments[fen] = comments[fen];\n      }\n    };\n\n    while (_history.length > 0) {\n      reversed_history.push(undo_move());\n    }\n\n    copy_comment(generate_fen());\n\n    while (reversed_history.length > 0) {\n      make_move(reversed_history.pop());\n      copy_comment(generate_fen());\n    }\n\n    comments = current_comments;\n  }\n\n  function _reset() {\n    _load(DEFAULT_POSITION);\n  }\n\n  function _load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n\n    var tokens = fen.split(/\\s+/);\n    var position = tokens[0];\n    var square = 0;\n\n    if (!_validate_fen(fen).valid) {\n      return false;\n    }\n\n    _clear(keep_headers);\n\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i);\n\n      if (piece === '/') {\n        square += 8;\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK;\n\n        _put({\n          type: piece.toLowerCase(),\n          color: color\n        }, algebraic(square));\n\n        square++;\n      }\n    }\n\n    _turn = tokens[1];\n\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE;\n    }\n\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]];\n    half_moves = parseInt(tokens[4], 10);\n    move_number = parseInt(tokens[5], 10);\n    update_setup(generate_fen());\n    return true;\n  }\n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n\n\n  function _validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square'\n    };\n    /* 1st criterion: 6 space-seperated fields? */\n\n    var tokens = fen.split(/\\s+/);\n\n    if (tokens.length !== 6) {\n      return {\n        valid: false,\n        error_number: 1,\n        error: errors[1]\n      };\n    }\n    /* 2nd criterion: move number field is a integer value > 0? */\n\n\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return {\n        valid: false,\n        error_number: 2,\n        error: errors[2]\n      };\n    }\n    /* 3rd criterion: half move counter is an integer >= 0? */\n\n\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return {\n        valid: false,\n        error_number: 3,\n        error: errors[3]\n      };\n    }\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n\n\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return {\n        valid: false,\n        error_number: 4,\n        error: errors[4]\n      };\n    }\n    /* 5th criterion: 3th field is a valid castle-string? */\n\n\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return {\n        valid: false,\n        error_number: 5,\n        error: errors[5]\n      };\n    }\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n\n\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return {\n        valid: false,\n        error_number: 6,\n        error: errors[6]\n      };\n    }\n    /* 7th criterion: 1st field contains 8 rows? */\n\n\n    var rows = tokens[0].split('/');\n\n    if (rows.length !== 8) {\n      return {\n        valid: false,\n        error_number: 7,\n        error: errors[7]\n      };\n    }\n    /* 8th criterion: every row is valid? */\n\n\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0;\n      var previous_was_number = false;\n\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return {\n              valid: false,\n              error_number: 8,\n              error: errors[8]\n            };\n          }\n\n          sum_fields += parseInt(rows[i][k], 10);\n          previous_was_number = true;\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return {\n              valid: false,\n              error_number: 9,\n              error: errors[9]\n            };\n          }\n\n          sum_fields += 1;\n          previous_was_number = false;\n        }\n      }\n\n      if (sum_fields !== 8) {\n        return {\n          valid: false,\n          error_number: 10,\n          error: errors[10]\n        };\n      }\n    }\n\n    if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n      return {\n        valid: false,\n        error_number: 11,\n        error: errors[11]\n      };\n    }\n    /* everything's okay! */\n\n\n    return {\n      valid: true,\n      error_number: 0,\n      error: errors[0]\n    };\n  }\n\n  function generate_fen() {\n    var empty = 0;\n    var fen = '';\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (_board[i] == null) {\n        empty++;\n      } else {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n\n        var color = _board[i].color;\n        var piece = _board[i].type;\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      }\n\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n\n        if (i !== SQUARES.h1) {\n          fen += '/';\n        }\n\n        empty = 0;\n        i += 8;\n      }\n    }\n\n    var cflags = '';\n\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K';\n    }\n\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q';\n    }\n\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k';\n    }\n\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q';\n    }\n    /* do we have an empty castling flag? */\n\n\n    cflags = cflags || '-';\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square);\n    return [fen, _turn, cflags, epflags, half_moves, move_number].join(' ');\n  }\n\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1];\n      }\n    }\n\n    return header;\n  }\n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n\n\n  function update_setup(fen) {\n    if (_history.length > 0) return;\n\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1';\n      header['FEN'] = fen;\n    } else {\n      delete header['SetUp'];\n      delete header['FEN'];\n    }\n  }\n\n  function _get(square) {\n    var piece = _board[SQUARES[square]];\n    return piece ? {\n      type: piece.type,\n      color: piece.color\n    } : null;\n  }\n\n  function _put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false;\n    }\n    /* check for piece */\n\n\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false;\n    }\n    /* check for valid square */\n\n\n    if (!(square in SQUARES)) {\n      return false;\n    }\n\n    var sq = SQUARES[square];\n    /* don't let the user place more than one king */\n\n    if (piece.type == KING && !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {\n      return false;\n    }\n\n    _board[sq] = {\n      type: piece.type,\n      color: piece.color\n    };\n\n    if (piece.type === KING) {\n      kings[piece.color] = sq;\n    }\n\n    update_setup(generate_fen());\n    return true;\n  }\n\n  function _remove(square) {\n    var piece = _get(square);\n\n    _board[SQUARES[square]] = null;\n\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY;\n    }\n\n    update_setup(generate_fen());\n    return piece;\n  }\n\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: _turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type\n    };\n\n    if (promotion) {\n      move.flags |= BITS.PROMOTION;\n      move.promotion = promotion;\n    }\n\n    if (board[to]) {\n      move.captured = board[to].type;\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN;\n    }\n\n    return move;\n  }\n\n  function generate_moves(options) {\n    function add_move(board, moves, from, to, flags) {\n      /* if pawn promotion */\n      if (board[from].type === PAWN && (rank(to) === RANK_8 || rank(to) === RANK_1)) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];\n\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]));\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags));\n      }\n    }\n\n    var moves = [];\n    var us = _turn;\n    var them = swap_color(us);\n    var second_rank = {\n      b: RANK_7,\n      w: RANK_2\n    };\n    var first_sq = SQUARES.a8;\n    var last_sq = SQUARES.h1;\n    var single_square = false;\n    /* do we want legal moves? */\n\n    var legal = typeof options !== 'undefined' && 'legal' in options ? options.legal : true;\n    var piece_type = typeof options !== 'undefined' && 'piece' in options && typeof options.piece === 'string' ? options.piece.toLowerCase() : true;\n    /* are we generating moves for a single square? */\n\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARES) {\n        first_sq = last_sq = SQUARES[options.square];\n        single_square = true;\n      } else {\n        /* invalid square */\n        return [];\n      }\n    }\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      var piece = _board[i];\n\n      if (piece == null || piece.color !== us) {\n        continue;\n      }\n\n      if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0];\n\n        if (_board[square] == null) {\n          add_move(_board, moves, i, square, BITS.NORMAL);\n          /* double square */\n\n          var square = i + PAWN_OFFSETS[us][1];\n\n          if (second_rank[us] === rank(i) && _board[square] == null) {\n            add_move(_board, moves, i, square, BITS.BIG_PAWN);\n          }\n        }\n        /* pawn captures */\n\n\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j];\n          if (square & 0x88) continue;\n\n          if (_board[square] != null && _board[square].color === them) {\n            add_move(_board, moves, i, square, BITS.CAPTURE);\n          } else if (square === ep_square) {\n            add_move(_board, moves, i, ep_square, BITS.EP_CAPTURE);\n          }\n        }\n      } else if (piece_type === true || piece_type === piece.type) {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j];\n          var square = i;\n\n          while (true) {\n            square += offset;\n            if (square & 0x88) break;\n\n            if (_board[square] == null) {\n              add_move(_board, moves, i, square, BITS.NORMAL);\n            } else {\n              if (_board[square].color === us) break;\n              add_move(_board, moves, i, square, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n\n\n            if (piece.type === 'n' || piece.type === 'k') break;\n          }\n        }\n      }\n    }\n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n\n\n    if (piece_type === true || piece_type === KING) {\n      if (!single_square || last_sq === kings[us]) {\n        /* king-side castling */\n        if (castling[us] & BITS.KSIDE_CASTLE) {\n          var castling_from = kings[us];\n          var castling_to = castling_from + 2;\n\n          if (_board[castling_from + 1] == null && _board[castling_to] == null && !attacked(them, kings[us]) && !attacked(them, castling_from + 1) && !attacked(them, castling_to)) {\n            add_move(_board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE);\n          }\n        }\n        /* queen-side castling */\n\n\n        if (castling[us] & BITS.QSIDE_CASTLE) {\n          var castling_from = kings[us];\n          var castling_to = castling_from - 2;\n\n          if (_board[castling_from - 1] == null && _board[castling_from - 2] == null && _board[castling_from - 3] == null && !attacked(them, kings[us]) && !attacked(them, castling_from - 1) && !attacked(them, castling_to)) {\n            add_move(_board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE);\n          }\n        }\n      }\n    }\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n\n\n    if (!legal) {\n      return moves;\n    }\n    /* filter out illegal moves */\n\n\n    var legal_moves = [];\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i]);\n      }\n\n      undo_move();\n    }\n\n    return legal_moves;\n  }\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n\n  function move_to_san(move, moves) {\n    var output = '';\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      if (move.piece !== PAWN) {\n        var disambiguator = get_disambiguator(move, moves);\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0];\n        }\n\n        output += 'x';\n      }\n\n      output += algebraic(move.to);\n\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n\n    make_move(move);\n\n    if (_in_check()) {\n      if (_in_checkmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n\n    undo_move();\n    return output;\n  } // parses all of the decorators out of a SAN string\n\n\n  function stripped_san(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n  }\n\n  function attacked(color, square) {\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      /* if empty square or wrong color */\n\n\n      if (_board[i] == null || _board[i].color !== color) continue;\n      var piece = _board[i];\n      var difference = i - square;\n      var index = difference + 119;\n\n      if (ATTACKS[index] & 1 << SHIFTS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true;\n          } else {\n            if (piece.color === BLACK) return true;\n          }\n\n          continue;\n        }\n        /* if the piece is a knight or a king */\n\n\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        var offset = RAYS[index];\n        var j = i + offset;\n        var blocked = false;\n\n        while (j !== square) {\n          if (_board[j] != null) {\n            blocked = true;\n            break;\n          }\n\n          j += offset;\n        }\n\n        if (!blocked) return true;\n      }\n    }\n\n    return false;\n  }\n\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color]);\n  }\n\n  function _in_check() {\n    return king_attacked(_turn);\n  }\n\n  function _in_checkmate() {\n    return _in_check() && generate_moves().length === 0;\n  }\n\n  function _in_stalemate() {\n    return !_in_check() && generate_moves().length === 0;\n  }\n\n  function _insufficient_material() {\n    var pieces = {};\n    var bishops = [];\n    var num_pieces = 0;\n    var sq_color = 0;\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      sq_color = (sq_color + 1) % 2;\n\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      var piece = _board[i];\n\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color);\n        }\n\n        num_pieces++;\n      }\n    }\n    /* k vs. k */\n\n\n    if (num_pieces === 2) {\n      return true;\n    } else if (\n    /* k vs. kn .... or .... k vs. kb */\n    num_pieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n      return true;\n    } else if (num_pieces === pieces[BISHOP] + 2) {\n      /* kb vs. kb where any number of bishops are all on the same color */\n      var sum = 0;\n      var len = bishops.length;\n\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function _in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = [];\n    var positions = {};\n    var repetition = false;\n\n    while (true) {\n      var move = undo_move();\n      if (!move) break;\n      moves.push(move);\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen().split(' ').slice(0, 4).join(' ');\n      /* has the position occurred three or move times */\n\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n\n      if (!moves.length) {\n        break;\n      }\n\n      make_move(moves.pop());\n    }\n\n    return repetition;\n  }\n\n  function push(move) {\n    _history.push({\n      move: move,\n      kings: {\n        b: kings.b,\n        w: kings.w\n      },\n      turn: _turn,\n      castling: {\n        b: castling.b,\n        w: castling.w\n      },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number\n    });\n  }\n\n  function make_move(move) {\n    var us = _turn;\n    var them = swap_color(us);\n    push(move);\n    _board[move.to] = _board[move.from];\n    _board[move.from] = null;\n    /* if ep capture, remove the captured pawn */\n\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (_turn === BLACK) {\n        _board[move.to - 16] = null;\n      } else {\n        _board[move.to + 16] = null;\n      }\n    }\n    /* if pawn promotion, replace with new piece */\n\n\n    if (move.flags & BITS.PROMOTION) {\n      _board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    }\n    /* if we moved the king */\n\n\n    if (_board[move.to].type === KING) {\n      kings[_board[move.to].color] = move.to;\n      /* if we castled, move the rook next to the king */\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1;\n        var castling_from = move.to + 1;\n        _board[castling_to] = _board[castling_from];\n        _board[castling_from] = null;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1;\n        var castling_from = move.to - 2;\n        _board[castling_to] = _board[castling_from];\n        _board[castling_from] = null;\n      }\n      /* turn off castling */\n\n\n      castling[us] = '';\n    }\n    /* turn off castling if we move a rook */\n\n\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && castling[us] & ROOKS[us][i].flag) {\n          castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n    /* turn off castling if we capture a rook */\n\n\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && castling[them] & ROOKS[them][i].flag) {\n          castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n    /* if big pawn move, update the en passant square */\n\n\n    if (move.flags & BITS.BIG_PAWN) {\n      if (_turn === 'b') {\n        ep_square = move.to - 16;\n      } else {\n        ep_square = move.to + 16;\n      }\n    } else {\n      ep_square = EMPTY;\n    }\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n\n\n    if (move.piece === PAWN) {\n      half_moves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0;\n    } else {\n      half_moves++;\n    }\n\n    if (_turn === BLACK) {\n      move_number++;\n    }\n\n    _turn = swap_color(_turn);\n  }\n\n  function undo_move() {\n    var old = _history.pop();\n\n    if (old == null) {\n      return null;\n    }\n\n    var move = old.move;\n    kings = old.kings;\n    _turn = old.turn;\n    castling = old.castling;\n    ep_square = old.ep_square;\n    half_moves = old.half_moves;\n    move_number = old.move_number;\n    var us = _turn;\n    var them = swap_color(_turn);\n    _board[move.from] = _board[move.to];\n    _board[move.from].type = move.piece; // to undo any promotions\n\n    _board[move.to] = null;\n\n    if (move.flags & BITS.CAPTURE) {\n      _board[move.to] = {\n        type: move.captured,\n        color: them\n      };\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index;\n\n      if (us === BLACK) {\n        index = move.to - 16;\n      } else {\n        index = move.to + 16;\n      }\n\n      _board[index] = {\n        type: PAWN,\n        color: them\n      };\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from;\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1;\n        castling_from = move.to - 1;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2;\n        castling_from = move.to + 1;\n      }\n\n      _board[castling_to] = _board[castling_from];\n      _board[castling_from] = null;\n    }\n\n    return move;\n  }\n  /* this function is used to uniquely identify ambiguous moves */\n\n\n  function get_disambiguator(move, moves) {\n    var from = move.from;\n    var to = move.to;\n    var piece = move.piece;\n    var ambiguities = 0;\n    var same_rank = 0;\n    var same_file = 0;\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      var ambig_from = moves[i].from;\n      var ambig_to = moves[i].to;\n      var ambig_piece = moves[i].piece;\n      /* if a move of the same piece type ends on the same to square, we'll\n       * need to add a disambiguator to the algebraic notation\n       */\n\n      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n        ambiguities++;\n\n        if (rank(from) === rank(ambig_from)) {\n          same_rank++;\n        }\n\n        if (file(from) === file(ambig_from)) {\n          same_file++;\n        }\n      }\n    }\n\n    if (ambiguities > 0) {\n      /* if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      if (same_rank > 0 && same_file > 0) {\n        return algebraic(from);\n      } else if (same_file > 0) {\n        /* if the moving piece rests on the same file, use the rank symbol as the\n         * disambiguator\n         */\n        return algebraic(from).charAt(1);\n      } else {\n        /* else use the file symbol */\n        return algebraic(from).charAt(0);\n      }\n    }\n\n    return '';\n  }\n\n  function infer_piece_type(san) {\n    var piece_type = san.charAt(0);\n\n    if (piece_type >= 'a' && piece_type <= 'h') {\n      var matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n\n      if (matches) {\n        return undefined;\n      }\n\n      return PAWN;\n    }\n\n    piece_type = piece_type.toLowerCase();\n\n    if (piece_type === 'o') {\n      return KING;\n    }\n\n    return piece_type;\n  }\n\n  function _ascii() {\n    var s = '   +------------------------+\\n';\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n      /* empty piece */\n\n\n      if (_board[i] == null) {\n        s += ' . ';\n      } else {\n        var piece = _board[i].type;\n        var color = _board[i].color;\n        var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      }\n\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h\\n';\n    return s;\n  } // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n\n\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    var clean_move = stripped_san(move);\n    var overly_disambiguated = false;\n\n    if (sloppy) {\n      // The sloppy parser allows the user to parse non-standard chess\n      // notations. This parser is opt-in (by specifying the\n      // '{ sloppy: true }' setting) and is only run after the Standard\n      // Algebraic Notation (SAN) parser has failed.\n      //\n      // When running the sloppy parser, we'll run a regex to grab the piece,\n      // the to/from square, and an optional promotion piece. This regex will\n      // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7, f7f8q,\n      // b1c3\n      // NOTE: Some positions and moves may be ambiguous when using the sloppy\n      // parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n      // the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated\n      // bishop move). In these cases, the sloppy parser will default to the\n      // most most basic interpretation - b1c3 parses to Nc3.\n      var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n\n      if (matches) {\n        var piece = matches[1];\n        var from = matches[2];\n        var to = matches[3];\n        var promotion = matches[4];\n\n        if (from.length == 1) {\n          overly_disambiguated = true;\n        }\n      } else {\n        // The [a-h]?[1-8]? portion of the regex below handles moves that may\n        // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n        // when there is one legal knight move to e7). In this case, the value\n        // of 'from' variable will be a rank or file, not a square.\n        var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n\n        if (matches) {\n          var piece = matches[1];\n          var from = matches[2];\n          var to = matches[3];\n          var promotion = matches[4];\n\n          if (from.length == 1) {\n            var overly_disambiguated = true;\n          }\n        }\n      }\n    }\n\n    var piece_type = infer_piece_type(clean_move);\n    var moves = generate_moves({\n      legal: true,\n      piece: piece ? piece : piece_type\n    });\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      // try the strict parser first, then the sloppy parser if requested\n      // by the user\n      if (clean_move === stripped_san(move_to_san(moves[i], moves))) {\n        return moves[i];\n      } else {\n        if (sloppy && matches) {\n          // hand-compare move properties with the results from our sloppy\n          // regex\n          if ((!piece || piece.toLowerCase() == moves[i].piece) && SQUARES[from] == moves[i].from && SQUARES[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n            return moves[i];\n          } else if (overly_disambiguated) {\n            // SPECIAL CASE: we parsed a move string that may have an unneeded\n            // rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n            var square = algebraic(moves[i].from);\n\n            if ((!piece || piece.toLowerCase() == moves[i].piece) && SQUARES[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n              return moves[i];\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n  /*****************************************************************************\n   * UTILITY FUNCTIONS\n   ****************************************************************************/\n\n\n  function rank(i) {\n    return i >> 4;\n  }\n\n  function file(i) {\n    return i & 15;\n  }\n\n  function algebraic(i) {\n    var f = file(i),\n        r = rank(i);\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n  }\n\n  function swap_color(c) {\n    return c === WHITE ? BLACK : WHITE;\n  }\n\n  function is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n  }\n  /* pretty = external move object */\n\n\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move);\n    move.san = move_to_san(move, generate_moves({\n      legal: true\n    }));\n    move.to = algebraic(move.to);\n    move.from = algebraic(move.from);\n    var flags = '';\n\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag];\n      }\n    }\n\n    move.flags = flags;\n    return move;\n  }\n\n  function clone(obj) {\n    var dupe = obj instanceof Array ? [] : {};\n\n    for (var property in obj) {\n      if (typeof property === 'object') {\n        dupe[property] = clone(obj[property]);\n      } else {\n        dupe[property] = obj[property];\n      }\n    }\n\n    return dupe;\n  }\n\n  function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }\n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n\n\n  function _perft(depth) {\n    var moves = generate_moves({\n      legal: false\n    });\n    var nodes = 0;\n    var color = _turn;\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = _perft(depth - 1);\n\n          nodes += child_nodes;\n        } else {\n          nodes++;\n        }\n      }\n\n      undo_move();\n    }\n\n    return nodes;\n  }\n\n  return {\n    /***************************************************************************\n     * PUBLIC CONSTANTS (is there a better way to do this?)\n     **************************************************************************/\n    WHITE: WHITE,\n    BLACK: BLACK,\n    PAWN: PAWN,\n    KNIGHT: KNIGHT,\n    BISHOP: BISHOP,\n    ROOK: ROOK,\n    QUEEN: QUEEN,\n    KING: KING,\n    SQUARES: function () {\n      /* from the ECMA-262 spec (section 12.6.4):\n       * \"The mechanics of enumerating the properties ... is\n       * implementation dependent\"\n       * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n       * ordered correctly\n       */\n      var keys = [];\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (i & 0x88) {\n          i += 7;\n          continue;\n        }\n\n        keys.push(algebraic(i));\n      }\n\n      return keys;\n    }(),\n    FLAGS: FLAGS,\n\n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function load(fen) {\n      return _load(fen);\n    },\n    reset: function reset() {\n      return _reset();\n    },\n    moves: function moves(options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n      var ugly_moves = generate_moves(options);\n      var moves = [];\n\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (typeof options !== 'undefined' && 'verbose' in options && options.verbose) {\n          moves.push(make_pretty(ugly_moves[i]));\n        } else {\n          moves.push(move_to_san(ugly_moves[i], generate_moves({\n            legal: true\n          })));\n        }\n      }\n\n      return moves;\n    },\n    in_check: function in_check() {\n      return _in_check();\n    },\n    in_checkmate: function in_checkmate() {\n      return _in_checkmate();\n    },\n    in_stalemate: function in_stalemate() {\n      return _in_stalemate();\n    },\n    in_draw: function in_draw() {\n      return half_moves >= 100 || _in_stalemate() || _insufficient_material() || _in_threefold_repetition();\n    },\n    insufficient_material: function insufficient_material() {\n      return _insufficient_material();\n    },\n    in_threefold_repetition: function in_threefold_repetition() {\n      return _in_threefold_repetition();\n    },\n    game_over: function game_over() {\n      return half_moves >= 100 || _in_checkmate() || _in_stalemate() || _insufficient_material() || _in_threefold_repetition();\n    },\n    validate_fen: function validate_fen(fen) {\n      return _validate_fen(fen);\n    },\n    fen: function fen() {\n      return generate_fen();\n    },\n    board: function board() {\n      var output = [],\n          row = [];\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (_board[i] == null) {\n          row.push(null);\n        } else {\n          row.push({\n            type: _board[i].type,\n            color: _board[i].color\n          });\n        }\n\n        if (i + 1 & 0x88) {\n          output.push(row);\n          row = [];\n          i += 8;\n        }\n      }\n\n      return output;\n    },\n    pgn: function pgn(options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\n';\n      var max_width = typeof options === 'object' && typeof options.max_width === 'number' ? options.max_width : 0;\n      var result = [];\n      var header_exists = false;\n      /* add the PGN header headerrmation */\n\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline);\n        header_exists = true;\n      }\n\n      if (header_exists && _history.length) {\n        result.push(newline);\n      }\n\n      var append_comment = function append_comment(move_string) {\n        var comment = comments[generate_fen()];\n\n        if (typeof comment !== 'undefined') {\n          var delimiter = move_string.length > 0 ? ' ' : '';\n          move_string = \"\".concat(move_string).concat(delimiter, \"{\").concat(comment, \"}\");\n        }\n\n        return move_string;\n      };\n      /* pop all of history onto reversed_history */\n\n\n      var reversed_history = [];\n\n      while (_history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n\n      var moves = [];\n      var move_string = '';\n      /* special case of a commented starting position with no moves */\n\n      if (reversed_history.length === 0) {\n        moves.push(append_comment(''));\n      }\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n\n\n      while (reversed_history.length > 0) {\n        move_string = append_comment(move_string);\n        var move = reversed_history.pop();\n        /* if the position started with black to move, start PGN with 1. ... */\n\n        if (!_history.length && move.color === 'b') {\n          move_string = move_number + '. ...';\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string);\n          }\n\n          move_string = move_number + '.';\n        }\n\n        move_string = move_string + ' ' + move_to_san(move, generate_moves({\n          legal: true\n        }));\n        make_move(move);\n      }\n      /* are there any other leftover moves? */\n\n\n      if (move_string.length) {\n        moves.push(append_comment(move_string));\n      }\n      /* is there a result? */\n\n\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result);\n      }\n      /* history should be back to what it was before we started generating PGN,\n       * so join together moves\n       */\n\n\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ');\n      }\n\n      var strip = function strip() {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop();\n          return true;\n        }\n\n        return false;\n      };\n      /* NB: this does not preserve comment whitespace. */\n\n\n      var wrap_comment = function wrap_comment(width, move) {\n        var _iterator = _createForOfIteratorHelper(move.split(' ')),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var token = _step.value;\n\n            if (!token) {\n              continue;\n            }\n\n            if (width + token.length > max_width) {\n              while (strip()) {\n                width--;\n              }\n\n              result.push(newline);\n              width = 0;\n            }\n\n            result.push(token);\n            width += token.length;\n            result.push(' ');\n            width++;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (strip()) {\n          width--;\n        }\n\n        return width;\n      };\n      /* wrap the PGN output at max_width */\n\n\n      var current_width = 0;\n\n      for (var i = 0; i < moves.length; i++) {\n        if (current_width + moves[i].length > max_width) {\n          if (moves[i].includes('{')) {\n            current_width = wrap_comment(current_width, moves[i]);\n            continue;\n          }\n        }\n        /* if the current move will push past max_width */\n\n\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop();\n          }\n\n          result.push(newline);\n          current_width = 0;\n        } else if (i !== 0) {\n          result.push(' ');\n          current_width++;\n        }\n\n        result.push(moves[i]);\n        current_width += moves[i].length;\n      }\n\n      return result.join('');\n    },\n    load_pgn: function load_pgn(pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\');\n      }\n\n      function has_keys(object) {\n        for (var key in object) {\n          return true;\n        }\n\n        return false;\n      }\n\n      function parse_pgn_header(header, options) {\n        var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n';\n        var header_obj = {};\n        var headers = header.split(new RegExp(mask(newline_char)));\n        var key = '';\n        var value = '';\n\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1');\n\n          if (trim(key).length > 0) {\n            header_obj[key] = value;\n          }\n        }\n\n        return header_obj;\n      }\n\n      var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n'; // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n\n      var header_regex = new RegExp('^(\\\\[((?:' + mask(newline_char) + ')|.)*\\\\])' + '(?:' + mask(newline_char) + '){2}'); // If no header given, begin with moves.\n\n      var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : ''; // Put the board in the starting position\n\n      _reset();\n      /* parse PGN header */\n\n\n      var headers = parse_pgn_header(header_string, options);\n\n      for (var key in headers) {\n        set_header([key, headers[key]]);\n      }\n      /* load the starting position indicated by [Setup '1'] and\n       * [FEN position] */\n\n\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && _load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false;\n        }\n      }\n      /* NB: the regexes below that delete move numbers, recursive\n       * annotations, and numeric annotation glyphs may also match\n       * text in comments. To prevent this, we transform comments\n       * by hex-encoding them in place and decoding them again after\n       * the other tokens have been deleted.\n       *\n       * While the spec states that PGN files should be ASCII encoded,\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\n       * as a convenience for modern users */\n\n\n      var to_hex = function to_hex(string) {\n        return Array.from(string).map(function (c) {\n          /* encodeURI doesn't transform most ASCII characters,\n           * so we handle these ourselves */\n          return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase();\n        }).join('');\n      };\n\n      var from_hex = function from_hex(string) {\n        return string.length == 0 ? '' : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'));\n      };\n\n      var encode_comment = function encode_comment(string) {\n        string = string.replace(new RegExp(mask(newline_char), 'g'), ' ');\n        return \"{\".concat(to_hex(string.slice(1, string.length - 1)), \"}\");\n      };\n\n      var decode_comment = function decode_comment(string) {\n        if (string.startsWith('{') && string.endsWith('}')) {\n          return from_hex(string.slice(1, string.length - 1));\n        }\n      };\n      /* delete header to get the moves */\n\n\n      var ms = pgn.replace(header_string, '').replace(\n      /* encode comments so they don't get deleted below */\n      new RegExp(\"({[^}]*})+?|;([^\".concat(mask(newline_char), \"]*)\"), 'g'), function (match, bracket, semicolon) {\n        return bracket !== undefined ? encode_comment(bracket) : ' ' + encode_comment(\"{\".concat(semicolon.slice(1), \"}\"));\n      }).replace(new RegExp(mask(newline_char), 'g'), ' ');\n      /* delete recursive annotation variations */\n\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '');\n      }\n      /* delete move numbers */\n\n\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n      /* delete ... indicating black to move */\n\n      ms = ms.replace(/\\.\\.\\./g, '');\n      /* delete numeric annotation glyphs */\n\n      ms = ms.replace(/\\$\\d+/g, '');\n      /* trim and get array of moves */\n\n      var moves = trim(ms).split(new RegExp(/\\s+/));\n      /* delete empty entries */\n\n      moves = moves.join(',').replace(/,,+/g, ',').split(',');\n      var move = '';\n      var result = '';\n\n      for (var half_move = 0; half_move < moves.length; half_move++) {\n        var comment = decode_comment(moves[half_move]);\n\n        if (comment !== undefined) {\n          comments[generate_fen()] = comment;\n          continue;\n        }\n\n        move = move_from_san(moves[half_move], sloppy);\n        /* invalid move */\n\n        if (move == null) {\n          /* was the move an end of game marker */\n          if (TERMINATION_MARKERS.indexOf(moves[half_move]) > -1) {\n            result = moves[half_move];\n          } else {\n            return false;\n          }\n        } else {\n          /* reset the end of game marker if making a valid move */\n          result = '';\n          make_move(move);\n        }\n      }\n      /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\n       * match the termination marker. Only do this when headers are present,\n       * but the result tag is missing\n       */\n\n\n      if (result && Object.keys(header).length && !header['Result']) {\n        set_header(['Result', result]);\n      }\n\n      return true;\n    },\n    header: function header() {\n      return set_header(arguments);\n    },\n    ascii: function ascii() {\n      return _ascii();\n    },\n    turn: function turn() {\n      return _turn;\n    },\n    move: function move(_move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n      var move_obj = null;\n\n      if (typeof _move === 'string') {\n        move_obj = move_from_san(_move, sloppy);\n      } else if (typeof _move === 'object') {\n        var moves = generate_moves();\n        /* convert the pretty move object to an ugly move object */\n\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (_move.from === algebraic(moves[i].from) && _move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || _move.promotion === moves[i].promotion)) {\n            move_obj = moves[i];\n            break;\n          }\n        }\n      }\n      /* failed to find move */\n\n\n      if (!move_obj) {\n        return null;\n      }\n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n\n\n      var pretty_move = make_pretty(move_obj);\n      make_move(move_obj);\n      return pretty_move;\n    },\n    undo: function undo() {\n      var move = undo_move();\n      return move ? make_pretty(move) : null;\n    },\n    clear: function clear() {\n      return _clear();\n    },\n    put: function put(piece, square) {\n      return _put(piece, square);\n    },\n    get: function get(square) {\n      return _get(square);\n    },\n    remove: function remove(square) {\n      return _remove(square);\n    },\n    perft: function perft(depth) {\n      return _perft(depth);\n    },\n    square_color: function square_color(square) {\n      if (square in SQUARES) {\n        var sq_0x88 = SQUARES[square];\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark';\n      }\n\n      return null;\n    },\n    history: function history(options) {\n      var reversed_history = [];\n      var move_history = [];\n      var verbose = typeof options !== 'undefined' && 'verbose' in options && options.verbose;\n\n      while (_history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop();\n\n        if (verbose) {\n          move_history.push(make_pretty(move));\n        } else {\n          move_history.push(move_to_san(move, generate_moves({\n            legal: true\n          })));\n        }\n\n        make_move(move);\n      }\n\n      return move_history;\n    },\n    get_comment: function get_comment() {\n      return comments[generate_fen()];\n    },\n    set_comment: function set_comment(comment) {\n      comments[generate_fen()] = comment.replace('{', '[').replace('}', ']');\n    },\n    delete_comment: function delete_comment() {\n      var comment = comments[generate_fen()];\n      delete comments[generate_fen()];\n      return comment;\n    },\n    get_comments: function get_comments() {\n      prune_comments();\n      return Object.keys(comments).map(function (fen) {\n        return {\n          fen: fen,\n          comment: comments[fen]\n        };\n      });\n    },\n    delete_comments: function delete_comments() {\n      prune_comments();\n      return Object.keys(comments).map(function (fen) {\n        var comment = comments[fen];\n        delete comments[fen];\n        return {\n          fen: fen,\n          comment: comment\n        };\n      });\n    }\n  };\n};\n/* export Chess object if using node or any other CommonJS compatible\n * environment */\n\n\nif (typeof exports !== 'undefined') exports.Chess = Chess;\n/* export Chess object for any RequireJS compatible environment */\n\nif (typeof define !== 'undefined') define(function () {\n  return Chess;\n});","map":null,"metadata":{},"sourceType":"script"}